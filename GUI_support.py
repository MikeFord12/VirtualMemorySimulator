#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.12
# In conjunction with Tcl version 8.6
#    Mar 27, 2018 06:51:49 PM

#Author: Mike Ford
#Date: 4/5/18

import sys

try:
    from Tkinter import *
    import  tkFileDialog
    import math
    from collections import namedtuple
except ImportError:
    from Tkinter import *

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

'''
Class: pageTable
Inputs: pages - how many pages will be in the pagetable

Summary: This object represents a page table with "pages" number of pages.
This creates a (pages x 2) 2d list. The page column values range from 0-pages.
The corresponding frame value b=can either be "get" or "set"
'''
class pageTable():
    def __init__(self,pages):
        self.pt = [[0 for x in range(2)] for y in range(pages)]

    def setPageTableItem(self,page,frameNum):
        self.pt[page][1] = frameNum

    def getPageTableFrameNum(self, page):
        return self.pt[page][1]
'''
Class: process
Inputs: pid - The processes ID number
codelength - length of code section in bytes
dataLength - length of data section in bytes
codePages - Number of pages required to hold code bytes (pages are 512 bytes)
dataPages - Number of pagers required to hold data bytes
codePageTable - a pageTable object to act as the processes' code page table
dataPageTable - a pageTable oject to act as the processes' data page table

Summary: This object holds all of the data for a loaded in process.
'''
class process():
    def __init__(self, pid, codeLength, dataLength, codePages, dataPages,codePageTable, dataPageTables):
        self.pid = pid
        self.codeLength = codeLength
        self.dataLength = dataLength
        self.codePages = codePages
        self.dataPages = dataPages
        self.codePageTable = codePageTable
        self.dataPageTable = dataPageTables
    def getCodeLength(self):
        return self.codeLength
    def getDataLength(self):
        return self.dataLength
    def getPID(self):
        return self.pid
    def getCodePages(self):
        return self.codePages
    def getDataPages(self):
        return self.dataPages
    def getCodePageTableFrame(self,page):
        return self.codePageTable.getPageTableFrameNum(page)
    def setCodePageTableFrame(self,page, frame):
        self.codePageTable.setPageTableItem(page,frame)
    def getDataPageTableFrame(self,page):
        return self.dataPageTable.getPageTableFrameNum(page)
    def setDataPageTableFrame(self,page,frame):
        self.dataPageTable.setPageTableItem(page, frame)
    def toString(self):
        return "Loading program %d into RAM: code=%d (%d pages), data=%d (%d pages)\n" % (self.pid,self.codeLength,self.codePages,self.dataLength,self.dataPages)

'''
Class: frame
Inputs: frameNumber - how many pages will be in the pagetable

Summary: This object represents a page table with "pages" number of pages.
This creates a (pages x 2) 2d list. The page column values range from 0-pages.
The corresponding frame value can either be "get" or "set"
'''
class frame():
    def __init__(self, frameNumber):
        self.frameNumber = frameNumber
        self.occupied = 0
        self.presentProcess = 999
    def getFrameNumber(self):
        return self.frameNumber
    def getOccupied(self):
        return self.occupied
    def getPresentProcess(self):
        return self.presentProcess
    def setOccupied(self, isOccupied):
        self.occupied = isOccupied
    def setPresentProcess(self,pid):
        self.presentProcess = pid

#sets up globals for program
def set_Tk_var():

    global FRAME_SIZE
    FRAME_SIZE = 512.0

    #all string variables below are used to set GUI message box texts
    global fileContent
    fileContent = StringVar()
    global pagesLoaded
    pagesLoaded = StringVar()
    global pagesString
    pagesString = ""
    global messageBoxStrings
    messageBoxStrings = []
    for num in range(0,8):
        messageBoxStrings.append(StringVar())
        messageBoxStrings[num].set("Free")
    #current line from file to read
    global line
    line = -1
    #holds file contents
    global operationList
    operationList = []
    #list for loaded processes and free frames
    global processList
    processList = []
    global freeFrames
    freeFrames = [frame(0),frame(1),frame(2),frame(3),frame(4),frame(5),frame(6),frame(7)]

#sorts free frames list by frame number (lowest to highest)
def sortFreeFrames(frames):
    frames.sort(key = lambda frame: frame.frameNumber)

#if the file menu option is selected, pop up a file selection window
def fileSelected():
    fileLines = ""
    filename = tkFileDialog.askopenfilename(initialdir="", title="Select file", filetypes=(
    ("text files", "*.txt"), ("all files", "*.*")))
    #open file selected
    inputFile = open(filename, "r")
    #read in lines
    for line in inputFile:
        operationList.append(line.rstrip())
    for element in operationList:
        fileLines+=(element + '\n')
    #set message window to file content
    fileContent.set(fileLines)

#processes each file line
def handleLine(line):
    global pagesString
    #split the line into the individual numbers
    numbersInLine = line.split(" ")
    numbersInLine = map(int, numbersInLine)
    #if line is 2 numbers, remove a process
    #if line is 3 numbers, load process
    if(len(numbersInLine) is 2):
       removeProcess(numbersInLine[0])
    if(len(numbersInLine) is 3):
        #create new process, add it to process list
        currentProcess = process(numbersInLine[0],numbersInLine[1],numbersInLine[2],(int)(math.ceil(numbersInLine[1]/FRAME_SIZE)),(int)(math.ceil(numbersInLine[2]/FRAME_SIZE)),pageTable((int)(math.ceil(numbersInLine[1]/FRAME_SIZE))),pageTable((int)(math.ceil(numbersInLine[2]/FRAME_SIZE))))
        processList.append(currentProcess)
        pagesString += currentProcess.toString()
        #print out process to message window and load process
        pagesLoaded.set(pagesString)
        addProcess(currentProcess)

def addProcess(process):
    global pagesString
    global freeFrames
    global line
    page = 0
    codeString = ""
    dataString = ""

    #check if theres enough available frames to add process
    if (process.getCodePages() + process.getDataPages()) > len(freeFrames):
        pagesString += "NOT ENOUGH FRAMES TO ALLOCATE PAGES.\n"
        pagesLoaded.set(pagesString)
        line -=1
    else:
        #while theres still code pages to add
        while (process.getCodePages() > page):
            #add page to first available frame and updae process page table
            process.setCodePageTableFrame(page, freeFrames[0].getFrameNumber())
            #get messages to print out ready, and then set message frames
            codeString = "Code-%d of P%d" % (page, process.getPID())
            pagesString += "Load code page %d of process %d to frame %d\n" % (page,process.getPID(),freeFrames[0].getFrameNumber())
            pagesLoaded.set(pagesString)
            messageBoxStrings[freeFrames[0].getFrameNumber()].set(codeString)
            #delete fram just used from free frames, resort free frames list
            del freeFrames[0]
            sortFreeFrames(freeFrames)
            page += 1

        page = 0
        #same process as code pages, except applied to data pages
        while (process.getDataPages() > page):

            freeFrames[0].setOccupied(1)
            process.setDataPageTableFrame(page, freeFrames[0].getFrameNumber())
            dataString = "Data-%d of P%d" % (page, process.getPID())
            pagesString += "Load data page %d of process %d to frame %d\n" % (
            page, process.getPID(), freeFrames[0].getFrameNumber())
            pagesLoaded.set(pagesString)
            messageBoxStrings[freeFrames[0].getFrameNumber()].set(dataString)
            del freeFrames[0]
            sortFreeFrames(freeFrames)
            page += 1

        page = 0

#remove process passed in
def removeProcess(processID):
    #return process object that corresponds to ID passed in
    processToRemove = findProcess(processID)
    global pagesString
    global freeFrames
    #loop through however many code pages to remove
    for x in range(processToRemove.getCodePages()):
        #add frame released back to free frames list, and resort
        freeFrames.append(frame(processToRemove.getCodePageTableFrame(x)))
        sortFreeFrames(freeFrames)
        #set message box of that frame to free
        messageBoxStrings[processToRemove.getCodePageTableFrame(x)].set("Free")
    #same process as removing code pages, but to data pages
    for x in range(processToRemove.getDataPages()):
        freeFrames.append(frame(processToRemove.getDataPageTableFrame(x)))
        sortFreeFrames(freeFrames)
        messageBoxStrings[processToRemove.getDataPageTableFrame(x)].set("Free")
    #setup and print end program message
    pagesString += "End of Program %d\n" % (processID)
    pagesLoaded.set(pagesString)

#return process object that matches ID passed in
def findProcess(processID):
    for process in processList:
        if processID is process.getPID():
            return process

#callback for next button
def nextButtonClicked():
    global line
    global pagesString
    line += 1
    #if line is more than lines in file, print out no more processes
    if line > len(operationList)-1:
        pagesString += "No more processes.\n"
        pagesLoaded.set(pagesString)
    else:
        handleLine(operationList[line])
#init GUI
def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
#closes window
def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None
#start GUI
if __name__ == '__main__':
    import GUI
    GUI.vp_start_gui()


